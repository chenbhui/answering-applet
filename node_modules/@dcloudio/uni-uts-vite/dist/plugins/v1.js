"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.uniUtsV1Plugin = void 0;
const path_1 = __importDefault(require("path"));
const uni_cli_shared_1 = require("@dcloudio/uni-cli-shared");
const compiler_1 = require("../utils/compiler");
function uniUtsV1Plugin() {
    let isFirst = true;
    return {
        name: 'uni:uts-v1',
        apply: 'build',
        enforce: 'pre',
        async transform(code, id, opts) {
            if (opts && opts.ssr) {
                return;
            }
            // 目前仅支持app-android
            if (process.env.UNI_UTS_PLATFORM !== 'app-android') {
                return;
            }
            const { filename } = (0, uni_cli_shared_1.parseVueRequest)(id);
            if (path_1.default.extname(filename) !== '.uts') {
                return;
            }
            const pkg = (0, compiler_1.parsePackage)(filename);
            if (!pkg) {
                return;
            }
            // 懒加载 uts 编译器
            // eslint-disable-next-line no-restricted-globals
            const { parse } = require('@dcloudio/uts');
            const ast = await parse(code, { noColor: (0, uni_cli_shared_1.isInHBuilderX)() });
            code = `
import { initUtsProxyClass, initUtsProxyFunction } from '@dcloudio/uni-app'
const pkg = '${pkg}'
const cls = 'IndexKt'
${genProxyCode(ast)}
`;
            const dexFile = await (0, compiler_1.compile)(id);
            if (!isFirst && dexFile) {
                const files = [];
                if (process.env.UNI_APP_CHANGED_DEX_FILES) {
                    try {
                        files.push(...JSON.parse(process.env.UNI_APP_CHANGED_DEX_FILES));
                    }
                    catch (e) { }
                }
                files.push(dexFile);
                process.env.UNI_APP_CHANGED_DEX_FILES = JSON.stringify([
                    ...new Set(files),
                ]);
            }
            return code;
        },
        buildEnd() {
            isFirst = false;
        },
    };
}
exports.uniUtsV1Plugin = uniUtsV1Plugin;
function genProxyFunctionCode(method, async, isDefault = false) {
    if (isDefault) {
        return `export default initUtsProxyFunction(${async}, { package: pkg, class: cls, name: '${method}'})`;
    }
    return `export const ${method} = initUtsProxyFunction(${async}, { package: pkg, class: cls, name: '${method}'})`;
}
function genProxyClassCode(cls, options, isDefault = false) {
    if (isDefault) {
        return `export default initUtsProxyClass({ package: pkg, class: '${cls}', ...${JSON.stringify(options)} })`;
    }
    return `export const ${cls} = initUtsProxyClass({ package: pkg, class: '${cls}', ...${JSON.stringify(options)} })`;
}
function genTsTypeAliasDeclarationCode(decl) {
    if (isFunctionType(decl.typeAnnotation)) {
        return genProxyFunctionCode(decl.id.value, isReturnPromise(decl.typeAnnotation.typeAnnotation));
    }
}
function genTsInterfaceDeclarationCode(decl, isDefault = false) {
    const cls = decl.id.value;
    const methods = {};
    decl.body.body.forEach((item) => {
        if (item.type === 'TsMethodSignature') {
            if (item.key.type === 'Identifier') {
                methods[item.key.value] = {
                    async: isReturnPromise(item.typeAnn),
                };
            }
        }
    });
    return genProxyClassCode(cls, { methods, staticMethods: {}, props: [], staticProps: [] }, isDefault);
}
function genFunctionDeclarationCode(decl, isDefault = false) {
    return genProxyFunctionCode(decl.identifier.value, decl.async || isReturnPromise(decl.returnType), isDefault);
}
function genClassDeclarationCode(decl, isDefault = false) {
    const cls = decl.identifier.value;
    const methods = {};
    const staticMethods = {};
    const props = [];
    const staticProps = [];
    decl.body.forEach((item) => {
        if (item.type === 'ClassMethod') {
            if (item.key.type === 'Identifier') {
                const name = item.key.value;
                const value = {
                    async: item.function.async || isReturnPromise(item.function.returnType),
                };
                if (item.isStatic) {
                    staticMethods[name] = value;
                }
                else {
                    methods[name] = value;
                }
            }
        }
        else if (item.type === 'ClassProperty') {
            if (item.key.type === 'Identifier') {
                if (item.isStatic) {
                    staticProps.push(item.key.value);
                }
                else {
                    props.push(item.key.value);
                }
            }
        }
    });
    return genProxyClassCode(cls, { methods, staticMethods, props, staticProps }, isDefault);
}
function genInitCode(expr) {
    switch (expr.type) {
        case 'BooleanLiteral':
            return expr.value + '';
        case 'NumericLiteral':
            return expr.value + '';
        case 'StringLiteral':
            return expr.value;
    }
    return '';
}
function genVariableDeclarationCode(decl) {
    // 目前仅支持 const 的 boolean,number,string
    const lits = ['BooleanLiteral', 'NumericLiteral', 'StringLiteral'];
    if (decl.kind === 'const' &&
        !decl.declarations.find((d) => {
            if (d.id.type !== 'Identifier') {
                return true;
            }
            if (!d.init) {
                return true;
            }
            const type = d.init.type;
            if (!lits.includes(type)) {
                return true;
            }
            return false;
        })) {
        return `export ${decl.kind} ${decl.declarations
            .map((d) => `${d.id.value} = ${genInitCode(d.init)}`)
            .join(', ')}`;
    }
}
function genProxyCode({ body }) {
    const codes = [];
    body.forEach((item) => {
        let code;
        if (item.type === 'ExportDeclaration') {
            const decl = item.declaration;
            switch (decl.type) {
                case 'FunctionDeclaration':
                    code = genFunctionDeclarationCode(decl, false);
                    break;
                case 'ClassDeclaration':
                    code = genClassDeclarationCode(decl, false);
                    break;
                case 'TsTypeAliasDeclaration':
                    code = genTsTypeAliasDeclarationCode(decl);
                    break;
                case 'TsInterfaceDeclaration':
                    code = genTsInterfaceDeclarationCode(decl, false);
                    break;
                case 'VariableDeclaration':
                    code = genVariableDeclarationCode(decl);
                    break;
            }
        }
        else if (item.type === 'ExportDefaultDeclaration') {
            const decl = item.decl;
            if (decl.type === 'TsInterfaceDeclaration') {
                code = genTsInterfaceDeclarationCode(decl, true);
            }
            else if (decl.type === 'ClassExpression') {
                if (decl.identifier) {
                    // export default class test{}
                    code = genClassDeclarationCode(decl, false);
                }
            }
            else if (decl.type === 'FunctionExpression') {
                if (decl.identifier) {
                    code = genFunctionDeclarationCode(decl, true);
                }
            }
        }
        if (code) {
            codes.push(code);
        }
    });
    return codes.join(`\n`);
}
function isFunctionType(type) {
    return type.type === 'TsFunctionType';
}
function isReturnPromise(anno) {
    if (!anno) {
        return false;
    }
    const { typeAnnotation } = anno;
    return (typeAnnotation.type === 'TsTypeReference' &&
        typeAnnotation.typeName.type === 'Identifier' &&
        typeAnnotation.typeName.value === 'Promise');
}
